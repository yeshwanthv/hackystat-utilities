#summary Description and instructions for downloading, and using a UriCache library in your code.

= 1.0 Introduction =

This User Guide provides instructions on how to download, install, configure, and use the Hackystat !UriCache library. It also provides simple examples of library usage.

The !UriCache system is a wrapper around [http://jakarta.apache.org/jcs/ Apache JCS] system which provides a backbone of the caching mechanism (and brings some overhead with libraries).

!UriCache is the memory cache which works according Least Recently Used (LRU) algorithm which discards the least recently used items first. The idea behind the implementing of this library is the communications optimization between Hackystat 8 components which described in the Philip's post [http://groups.google.com/group/hackystat-dev/msg/9379f301b9db710b "RFC: Caching"].

The current !UriCache implementation assumes that cached items are not eternal, i.e. they can expire. By default items will expire in 24 hours after they are added to the cache, it is possible to change auto expiration time by specifying another value. Note, that it is possible to specify items expiration time by maximum memory idle time also, items will be actively removed from the cache if they are not used within the time frame specified.

Also you can define the maximum life of an individual item by setting the expirationTimeStamp parameter when adding item in the cache. If an item has been in the cache for longer than the set timestamp value it will be removed from the cache. Note that this method overrides the high-level expiration settings. 

Current implementation of the !UriCache use the background memory shrinker which runs each 60 seconds to delete items which are expired. 

= 2.0 Downloading =

You will normally want to download the latest distribution of the !UriCache with others !HackyStat utilities from the [http://hackystat-utilities.googlecode.com/downloads/list Downloads] page. The file will be named hackystat-utilities-{version}.zip. Inside the archive you will find a uricache.lib.jar file which is the !UriCache library.

It is also possible to download the sources from the [http://code.google.com/p/hackystat-utilities/source Hackystat-Utilities SVN repository], but in that case you will need to build the library from sources. The distribution package comes with both sources and a pre-built libraries.

= 3.0 Prerequisites =

Before using UriCache library you will need to install next packages and configure environment variables along with CLASSPATH variables within the Eclipse as follows:

|| *Package* || *Version* || *Environment/Classpath Variable* || *Sample Env Value* ||
|| [http://commons.apache.org/logging/ Apache Commons Logging] || 1.1 ||APACHE_COMMONS_LOGGING_HOME || c:\tools\commons-logging-1.1 ||
|| [http://jakarta.apache.org/jcs/ Apache Java Caching System] || 1.3 || APACHE_JCS_HOME || c:\tools\apache-jcs-1.3 ||

While !UriCache as JCS relies on usage of util.concurrent Release 1.3.4. by [http://gee.cs.oswego.edu/dl Doug Lea] this particular library included within the !UriCache package.

= 4.0 Usage =

In order to use !UriCache library in your code you need to put uricache.lib.jar within your build and run CLASSPATH. Upon instantiation of !UriCache object it will initialize memory cache for it's own use. The memory cache volume limited by default to 500 items and the auto expiration time is set to 24 hours.  There is a list of methods you might want to use:

== 4.1. Getting cache instance ==

Use the default constructor to get !UriCache instance: `myURICache = new UriCache();`.

It is possible to configure the cache capacity and items default expiration time by using another constructor: `myURICache = new UriCache(CacheCapacity, maxLifeSeconds);`.

== 4.2. Caching an item ==

To cache an item you may use two methods:

  `cache(String uriString, Object obj)` - this methods caches the item using as a key URI string provided as the first parameter.

  `cache(String uriString, Object obj, XMLGregorianCalendar expirationTime)` - this method caches an item and specifies its expiration time.

== 4.3. Retrieving items from the cache ==

To check an item presence within the cache and retrieve it `lookup(String uriString)` method used. It returns item if it was found within the cache or `null` if it wasn't.

== 4.4. Removing object from cache == 

To remove an item from cache `remove(String uriString)` method might be used.

You may use `clear()` method to purge the whole cache.

== 4.5. Automatically purging the cache items by memory idle time ==

To specify a time interval value for the automatic cache purging the `setMaxMemoryIdleTimeSeconds(int seconds)` method used. !UriCache will actively free the memory used by the items if this memory wasn't read within the time interval specified.

You may want see [http://hackystat-utilities.googlecode.com/svn/trunk/javadoc/org/hackystat/utilities/uricache/UriCache.html UriCache JavaDocs] for additional information.

= 5.0 Code samples = 
This section provides couple of code samples to help you understand the library usage.

== 5.1. Default cache test ==
In this code we will get an UriCache instance configured according to default settings and will test the cache functionality.
{{{
      // getting default UriCache instance
      UriCache myURICache = new UriCache();

      //
      // testing caching 
      //
      for (int i = 0; i < 500; i++) {
        myURICache.cache(String.valueOf(i), i);
      }

      for (int i = 0; i < 501; i++) {
        Integer j = (Integer) myURICache.lookup(String.valueOf(i));
        System.out.println("For the key " + i + " got value " + j);
      }

}}}

Expected output for this code (beside the cache configuration INFO) is as follows:
{{{
For the key 0 got value 0
For the key 1 got value 1

...

For the key 500 got value null
}}}

== 5.1. Auto expiration of cached items test ==
In this code we will get an UriCache instance configured to auto expire cached items in 5 seconds along with the bigger cache capacity:
{{{
      Integer idleTimeSeconds = 5; 
  
      // getting UriCache instance
      myURICache = new UriCache(10000, idleTimeSeconds);

      // caching 10000 items
      for (int i = 0; i < 10000; i++) {
        myURICache.cache(String.valueOf(i), i);
      }

      // sleeping for two minutes
      System.out.println("idle time seconds=" + idleTimeSeconds);
      long sleepTime = 1000 * 120;
      System.out.println("sleeping for " + sleepTime
          + " millis to allow cache elements to be flagged as idle for too long");
      Thread.sleep(sleepTime);

      // checking cachce content
      for (int i = 0; i < 10001; i++) {
        Integer j = (Integer) myURICache.lookup(String.valueOf(i));
        System.out.println("For the key " + i + " got value " + j);
      }

}}}


The expected output for this code will contain four sections:
 * the cache configuration info which looks like:
 {{{
Sep 4, 2007 9:52:12 AM org.apache.jcs.engine.memory.lru.LRUMemoryCache initialize
INFO: initialized LRUMemoryCache for UriCache
Sep 4, 2007 9:52:12 AM org.apache.jcs.engine.control.CompositeCache <init>
INFO: Constructed cache with name [UriCache] and cache attributes [ useLateral = false, useRemote = false, useDisk = false, maxObjs = 10000, maxSpoolPerRun = -1, diskUsagePattern = 0 ]
Sep 4, 2007 9:52:12 AM org.apache.jcs.engine.control.CompositeCacheConfigurator parseRegions
INFO: Parsed regions [UriCache]
Sep 4, 2007 9:52:12 AM org.apache.jcs.engine.control.CompositeCacheConfigurator doConfigure
INFO: Finished configuration in 0 ms.
 }}}
 * sleeping message
{{{
idle time seconds=5
sleeping for 120000 millis to allow cache elements to be flagged as idle for too long
}}}
 * whole bunch of shrinker info messages about expiring elements:
{{{
Sep 4, 2007 9:53:12 AM org.apache.jcs.engine.memory.shrinking.ShrinkerThread checkForRemoval
INFO: Exceeded maxLifeSeconds: 3613
Sep 4, 2007 9:53:12 AM org.apache.jcs.engine.memory.shrinking.ShrinkerThread checkForRemoval

....

INFO: Exceeded maxLifeSeconds: 3612
Sep 4, 2007 9:53:12 AM org.apache.jcs.engine.memory.shrinking.ShrinkerThread checkForRemoval
}}}
 * and finally we will not see any of the items in the cache:
{{{
For the key 0 got value null
For the key 1 got value null

...

For the key 9999 got value null
For the key 10000 got value null
}}}











